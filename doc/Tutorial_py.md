Tutorial
========

## Pythonライブラリ(qlazypy)

### 使用例

まず、簡単な使用例を示します。

    from qlazypy import QState
    
    # ２つの量子ビットを|0>に初期化
    qs = QState(2)

    # 量子ゲート実行
    qs.h(0)
    qs.cx(0,1)
    qs.show()    # 量子状態の表示

    # 測定
    md = qs.m()
	md.show()    # 測定結果の表示

    # 後始末（メモリ開放）
    qs.free()

何をやっているか順に説明します。まず、QState()で量子ビットを各々|0>に
初期化します。初期化した量子状態に対して、次々に量子ゲートを作用させ、
最後に測定して結果を表示する、というのが典型的な使用方法です。上の例で
は、０番目の量子ビットにアダマールゲートをかけ、０番目と１番目の量子ビッ
トに制御NOTゲートをかけています。qlazyではh()やcx()などの量子ゲートに
対応したメソッドを呼び出した時点で、量子状態を変更させる計算を内部で行っ
ています。他のシミュレータの多くは量子回路を定義した上で、最後にrunす
るような仕様が多いように思いますが、その点ご注意ください。

また、連続して適用したい場合、

    qs.h(0).cx(0,1)
	
のような書き方も可能です。

量子状態は、show()メソッドで確認できます。上の例では、以下のような表示
がなされます。

    c[00] = +0.7071+0.0000*i : 0.5000 |++++++
    c[01] = +0.0000+0.0000*i : 0.0000 |
    c[10] = +0.0000+0.0000*i : 0.0000 |
    c[11] = +0.7071+0.0000*i : 0.5000 |++++++

２量子ビットで実行しているので、量子状態は|00>,|01>,|10>,|11>の重ね合
わせです。各々に対応した係数（複素数）をc[00],c[01],c[10],c[11]と定義
しており、それを表示しています。複素数の右に表示されている実数値
（0.5000とか0.0000）は各々の絶対値の２乗、すなわちその状態が観測される
確率を表しています。一番右に表示されている「++++++」は、その確率の大き
さを視覚的にわかりやすくするための、棒グラフです。

量子ゲートの操作が終わったら、m()メソッドで測定します。測定結果を適当
な変数で受けて、それをshow()メソッドで表示します。上の例では、例えば以
下のように表示されます。

    direction of measurement: z-axis
    frq[00] = 49
    frq[11] = 51
    last state => 00

はじめの行「direction of measurement: z-axis」は、Z軸方向の測定をして
います、ということ表しています。デフォルトの測定の方向はZ軸方向です。
他の大抵のシミュレータと違い、qlazyでは任意方向の測定もオプション等で
簡単に実行できるので、区別できるように測定方向を一応表示するようにして
います。frq[xx]は、測定の結果、|xx>だった回数を表しています。測定の回
数は、何も指定しなければ、デフォルトで100回です。上の例では、|00>だっ
た回数は49回、|11>だった回数は51回だったということを表しています。内部
で乱数を発生させることで確率的な測定をシミュレートしていますので、実行
のたびにこの回数は変わります。last stateは、最後の測定の結果が何だった
かを表しています。上の例では|00>でした。qlazyでは、測定後の状態変化も
シミュレーションしていますので、この測定後の状態に対して、

    qs.show()
	
をすると、以下のように、波束が収縮している様子も確認することができます。

    c[00] = +1.0000+0.0000*i : 1.0000 |+++++++++++
    c[01] = +0.0000+0.0000*i : 0.0000 |
    c[10] = +0.0000+0.0000*i : 0.0000 |
    c[11] = +0.0000+0.0000*i : 0.0000 |

すべて終わったら、後始末をします。

    qs.free()
	
qlazyは実質的な計算はすべてC言語で作成したライブラリで行っており、それ
をCtypesを使って呼び出す形にしています。量子状態を格納しておくメモリは
C言語側で動的に確保していますので、最後に、そのメモリを開放するという
意味でfree()が必要です。

### 量子状態へのゲート適用

#### 量子状態の生成・初期化

まず、量子状態の生成・初期化をする必要があります。量子ビット数を引数に
してQStateクラスのコンストラクタを呼び出すのが基本ですが、乱数生成のシー
ドを指定するオプションもあります。

    qs = QState(2, seed=123)

デフォルトではseedはランダムに設定されるので実行のたびに結果は変わ
りますが、このseedを指定すると、何度実行しても結果は同じになります。

この初期化について、２つ注意事項があります。

1. 状態は常に|00...0>になります。どれかを|1>にする初期化機能は用意して
いません。それをしたい場合はパウリXゲートを使ってビット反転してください。
2. 指定できる量子ビット数の上限は30です。30を超えるとエラーになります。

また、numpyのベクトルを使って、量子状態を初期化することもできます。使
い方は、以下です。

    import numpy as np
    vec = np.array([1,0,0,0])
    qs = QState(vector=vec)

指定するベクトルの次元は２のべき乗である必要があります。

##### 30の上限を外したい場合

qlazy/c/qlazy.hの以下の行の数字を変えて、再度コンパイルして、

    #define MAX_QUBIT_NUM      30

さらに、qlazy/py/qlazypy/config.pyの以下の行の数字を上と同じになるよう
に変更してください。

    MAX_QUBIT_NUM = 30

#### パウリX,Y,Zゲート

    qs.x(id)
    qs.y(id)
    qs.z(id)
	
#### ルートパウリXゲート

２乗したらXになるゲートです。

    qs.xr(id)
    qs.xr_dg(id)  # エルミート共役


#### アダマールゲート

    qs.h(id)

#### 位相シフトゲート

    qs.s(id)
    qs.t(id)
    qs.s_dg(id)  # エルミート共役
    qs.t_dg(id)  # エルミート共役
	
#### 回転ゲート

    qs.rx(id, phase=xxx)  # X軸周りの回転
    qs.ry(id, phase=xxx)  # Y軸周りの回転
    qs.rz(id, phase=xxx)  # Z軸周りの回転
	
phase（実数値）が指定されなければ0ラジアンとみなされます（つまり何もし
ない）。phaseに指定する値の単位はPIラジアンです。なので、0.5は0.5*PIラ
ジアンを意味します。

#### 回転ゲート(U1,U2,U3 by IBM)

    qs.u1(id, alpha=xxx)
    qs.u2(id, alpha=xxx, beta=xxx)
    qs.u3(id, alpha=xxx, beta=xxx, gamma=xxx)
	
alpha,beta,gamma（実数値）が指定されなければ0ラジアンとみなされます
（つまり何もしない）。phaseに指定する値の単位はPIラジアンです。なので、
0.5は0.5*PIラジアンを意味します。

#### 制御ユニタリゲート

パウリX,Y,Zゲート、ルートパウリXゲート、アダマールゲート、位相シフトゲー
ト、回転ゲートを各々制御ユニタリ化したゲートです。

    qs.cx(id_0,id_1)              # 制御Xゲート（制御NOT,CNOT）
    qs.cy(id_0,id_1)              # 制御Xゲート
    qs.cz(id_0,id_1)              # 制御Zゲート
    qs.cxr(id_0,id_1)             # 制御XR(ルートパウリX)ゲート
    qs.cxr_dg(id_0,id_1)          # 制御XR+(ルートパウリX)ゲート (エルミート共役)
    qs.ch(id_0,id_1)              # 制御Hゲート
    qs.cs(id_0,id_1)              # 制御Sゲート
    qs.cs_dg(id_0,id_1)           # 制御S+ゲート (エルミート共役)
    qs.ct(id_0,id_1)              # 制御Tゲート
    qs.ct_dg(id_0,id_1)           # 制御T+ゲート (エルミート共役)
	qs.cp(id_0,id_1, phase=xxx)   # 制御位相シフトゲート
	qs.crx(id_0,id_1, phase=xxx)  # 制御X軸回転ゲート
	qs.cry(id_0,id_1, phase=xxx)  # 制御Y軸回転ゲート
	qs.crz(id_0,id_1, phase=xxx)  # 制御Z軸回転ゲート
	qs.cu1(id_0,id_1, alpha=xxx)                       # 制御U1ゲート
	qs.cu2(id_0,id_1, alpha=xxx, beta=xxx)             # 制御U2ゲート
	qs.cu3(id_0,id_1, alpha=xxx, beta=xxx, gamma=xxx)  # 制御U2ゲート

#### 交換ゲート（スワップゲート）

    qs.sw(id_0,id_1)  # id_0とid_1を入れ替え

#### トフォリゲート

    qs.ccx(id_0,id_1,id_2)  # id_0,id_1: 制御ビット

#### 制御スワップゲート（フレドキンゲート）

    qs.csw(id_0,id_1,id_2)  # id_0: 制御ビット


### 量子状態の表示

#### 正規化

ノルムを1にする正規化に加えて、全体にかかっている位相項を括り出して、
これを無視して表示するようにしています。位相項を括り出す際には、
C[00..0]の係数が正の実数になるようにしています。

#### 特定量子ビットの状態表示

量子ビット全体の状態を表示するのが基本ですが、特定の量子ビットを選択し
て表示することもできます。

    qs.show(id=[id_0,id_1...])

例えば、

    qs = QState(3)
	qs.h(0)
	qs.h(2)
	qs.show()

とすると、全体の状態が表示されます。

    c[000] = +0.5000+0.0000*i : 0.2500 |++++
    c[001] = +0.5000+0.0000*i : 0.2500 |++++
    c[010] = +0.0000+0.0000*i : 0.0000 |
    c[011] = +0.0000+0.0000*i : 0.0000 |
    c[100] = +0.5000+0.0000*i : 0.2500 |++++
    c[101] = +0.5000+0.0000*i : 0.2500 |++++
    c[110] = +0.0000+0.0000*i : 0.0000 |
    c[111] = +0.0000+0.0000*i : 0.0000 |

ここで、

    qs.show(id=[0,2])

とすると、以下になります。

    c[00] = +0.5000+0.0000*i : 0.2500 |++++
    c[01] = +0.5000+0.0000*i : 0.2500 |++++
    c[10] = +0.5000+0.0000*i : 0.2500 |++++
    c[11] = +0.5000+0.0000*i : 0.2500 |++++

また、

    qs.show(id=[1])
	
とすると、以下になります。

    c[0] = +1.0000+0.0000*i : 1.0000 |+++++++++++
    c[1] = +0.0000+0.0000*i : 0.0000 |

内部的にどんなことをやっているかというと、表示したい特定の量子ビット以
外のビットを仮に測定し無理やり波束を収縮させます。結果得られた確率振幅
の係数たちの中から、表示したい量子ビットの組み合わせに相当するノンゼロ
の係数をピックアップして表示します。ノンゼロの係数がなかったらゼロとし
ます。最後に、測定前の状態に戻します。以上がやっている内容です。

したがって、表示したい量子ビットとそれ以外の量子ビットの世界がきっぱり
とテンソル積で分解できる形になっていれば、これで予想通りの表示がなされ
ます。問題はエンタングルしていてテンソル積の形になっていない場合です。
この実装だとshowで表示するたびに結果が変わります。例えば、

    c[00] = +0.7071+0.0000*i : 0.5000 |++++++
    c[01] = +0.0000+0.0000*i : 0.0000 |
    c[10] = +0.0000+0.0000*i : 0.0000 |
    c[11] = +0.7071+0.0000*i : 0.5000 |++++++

のようなエンタングルした状態があったときに、

    qs.show(id=[0])
   
をやると、

    c[0] = +1.0000+0.0000*i : 1.0000 |+++++++++++
    c[1] = +0.0000+0.0000*i : 0.0000 |

となったり、

    c[0] = +0.0000+0.0000*i : 0.0000 |
    c[1] = +1.0000+0.0000*i : 1.0000 |+++++++++++

となったりします。

まー、これはこれで面白いし（エンタングルしていたということがわかる）、
こんな適当実装でも結構使える場合も多いかなと個人的には思っています。

ちなみに、これは、エンタングルした純粋状態の部分トレースをとった結果と
して現れた|0>と|1>の混合状態を表示していることに相当します。純粋状態で
はないので、複数の純粋状態が確率的に表示されるわけです。

ということですので、注意して使ってください。

#### 量子状態のデータ取得

ampプロパティで、確率振幅の各々の複素係数をnumpy配列として取得できます。

    qs.amp

get_amp()メソッドで、特定の量子ビットに対応した確率振幅の複素係数をnumpy
配列として取得できます。

    qs.get_amp(id=[id_0,id_1...])

#### ブロッホ球上での座標

blochメソッドで、特定の１つの量子ビットに対応したブロッホ球での座標値
を取得できます。thetaをZ軸とのなす角、phiをZ軸周りの回転角とすると、以
下のように座標値を取得できます。角度の単位はpi(ラジアン)です。0.5は
0.5*piを表します。

    theta, phi = qs.bloch(qid=id_0)

ただし、複数の量子ビットを同時に指定することはできません。引数を指定し
ない場合、0が指定されたものとみなされます。

### 測定

#### 測定の実行

    md = qs.m(id=[id_0,id_1...], shots=aaa, angle=bbb, phase=ccc)

id,shots,angle,phaseの指定をしない場合、通常のZ軸方向の測定を100回実施
します。idには測定したい量子ビットの番号リストを指定します。shotsには
測定回数を指定します。angle,phaseは測定の方向を表しており、angleにはZ
軸とのなす角を単位PIラジアンで指定します。phaseにはX軸プラス方向を基準
にしたZ軸周りの角度を単位PIラジアンで指定します。ブロッホ球の２つの角
をイメージしてもらえれば良いです。この測定メソッドは、測定クラスの イ
ンスタンスを返すので、それを例えば変数mdで受けるというのが、よくやる使
い方です。

X軸、Y軸、Z軸方向の測定をするメッソドも用意されています。

    md = qs.mx(id=[id_0,id_1...], shots=aaa)
    md = qs.my(id=[id_0,id_1...], shots=aaa)
    md = qs.mz(id=[id_0,id_1...], shots=aaa)

mz()はm()と同じです。

また、ベル測定のメソッドもあります。

    md = qs.mb(id=[id_0,id_1], shots=aaa)


#### 測定結果の表示

show()メソッドで表示します。Z軸方向以外の測定結果の表示例を以下に示し
ます。Z軸方向の測定結果は|0>,|1>ですが、それ以外の方向は|0>,|1>にはな
らないので、|u>,|d>になるとして、結果を表しています。

X軸方向の測定結果

    direction of measurement: x-axis
    frq[u] = 49
    frq[d] = 51
    last state => u

Y軸方向の測定結果

    direction of measurement: y-axis
    frq[u] = 51
    frq[d] = 49
    last state => d

任意方向の測定結果（angle=0.2, phase=0.3の場合）

    direction of measurement: theta=0.200*PI, phi=0.300*PI
    frq[u] = 90
    frq[d] = 10
    last state => u

ベル測定の結果

    bell-measurement
    frq[phi+] = 47
    frq[phi-] = 53
    last state => phi+  # phi+,phi-,psi+,psi-のどれか

#### 測定データの取得

    md.frq  # 頻度リスト
	md.lst  # 最後の結果
	
最後の結果は、十進数になります。Z軸方向以外の測定の場合、u=>0,d=>1のよ
うに読み替えて、十進数にしています。ベル測定の場合は、phi+ => 0, phi-
=> 3, psi+ => 1, psi- => 2と定義されています。


### 量子状態とオブザーバブル

ハミルとニアンをはじめとする観測可能な物理量のことを「オブザーバブル」
といいます。qlazyでは、量子状態とオブザーバブルにまつわるいくつかの計
算もできます。オブザーバブルを利用可能とするために、QStateクラスに加え、
Observableクラスをimportする必要があります。

    from qlazypy import QState,Observable

利用可能な計算は、

    * 量子状態の時間発展
    * オブザーバブルの期待値
	
です。

#### 量子状態の時間発展

系のハミルトニアンが与えられたら、量子状態の時間発展は形式的にはユニタ
リ演算子として記述できます。このユニタリ演算子のことを「時間発展演算子」
と呼びます。特に、スピンのような２準位の多体系の場合、この時間発展演算
子は、量子回路によって近似的に表現できることが知られています。qlazyで
は、この計算を実装しています。QStateクラスのevolveメソッドを使います。
使用例を以下に示します。

    qs = QState(2)
    hm = Observable("-2.0+z_0*z_1+x_0+x_1")
    qs.evolve(observable=hm, time=0.1, iter=10)
	
１行目で、２粒子を定義しています。量子状態は|00>に初期化されます。２行
目で、"-2.0*Z0*Z1+X0+X1"というパウリ行列で記述されるハミルトニアンを定
義しています。３行目で、このハミルトニアンで規定される時間発展を量子状
態qsに施しています。ここで、引数timeは時間です。iterは近似精度を上げる
ために内部で処理される繰り返し数(整数値)です。timeよりも十分大きな値を
指定してください。

#### オブザーバブルの期待値

QStateクラスのexpectメソッドを使います。使用例を以下に示します。上で示
した例の続きです。

    ob = Observable("z_0+z_1")
    exp = qs.expect(observable=ob)

１行目で、期待値を求めたい物理量(オブザーバブル)を指定します。２行目で、
現在の量子状態qsに対するオブザーバブルの期待値を計算して、変数exp(実数
値)に格納しています。

### 量子状態に関する計算

#### ２つの量子状態の内積

QStateクラスのinproメソッドを使います。使用例を以下に示します。

    qs_0 = QState(2)
    qs_1 = QState(2).x(0).x(1)
    v = qs_0.inpro(qs_1)

状態|00>と状態|11>の内積を計算しています。

#### ２つの量子状態のテンソル積

QStateクラスのtensproメソッドを使います。使用例を以下に示します。

    qs_1 = QState(1).x(0)
    qs_2 = QState(2).h(0).cx(0,1)
    qs_3 = qs_1.tenspro(qs_2)

|1>と(|00>+|11>)/sqrt(2)のテンソル積を作成し、変数qs_3に格納しています。

#### 量子状態への行列適用

QStateクラスのapplyメソッドを使います。行列をnumpyの配列として定義し、
applyメソッドの引数として渡します。使用例を以下に示します。

    qs = QState(1)	
    M = np.array([[0,1],[1,0]])
	qs.apply(M)

１量子ビット状態|0>にビット反転演算（Xゲート）を適用しています。


### 密度演算子

量子状態には純粋状態と混合状態があります。混合状態は、複数の純粋状態が
ある確率でもって出現するアンサンブル{p(i), |phi(i)} (i=0,1,2,...)とし
て定義されます。このような混合状態も含めて、量子状態を統一的に記述する
便利な記法として「密度演算子」が導入されませした。その定義は、密度演算
子をrhoとすると、「rho = ∑_i p(i) |phi(i)><phi(i)|」です。

qlazyには、通常の量子状態の集合から密度演算子をつくり、各種計算する機
能があります。以下にそれらを記載します。

#### 作成

DensOpクラスが密度演算子を表します。使用例を以下に示します。

    from qlazypy import QState,DensOp

    qs1 = QState(2).h(0).cx(0,1)
    qs2 = QState(2).x(0).z(1)

    de = DensOp(qstate=[qs1,qs2], prob=[0.3,0.7])

２つの量子状態qs1,qs2があったとき、DensOpの引数として、量子状態のリス
トと各々の出現確率を表すリストを与えると、密度演算子のインスタンスが返っ
てきます。量子状態は、何個指定しても良いです（メモリが許す限り）。

numpyの行列（２次元配列）を指定して生成することもできます。使い方は、
以下です。

    import numpy as np
	mat = np.array([[1,0],[0.0]])
    de = DensOp(matrix=mat)

#### トレース

DensOpクラスのtraceメソッドを使います。使用例を以下に示します。

    tr = de.trace()

密度演算子のトレースは理論的には「常に1である」ということになっている
ので、たいていの場合、あまり意味はないメソッドですが、密度演算子に対し
て、何らかの行列変換を適用しておいて(後述)、そのトレースを計算したい場
合があります。その場合、このメソッドを使うことで、計算できます。

#### ２乗のトレース

DensOpクラスのsqtraceメソッドを使います。使用例を以下に示します。

    sqtr = de.sqtrace()

密度演算子を２乗してから、そのトレースをとります。純粋状態の密度演算子
の場合、この値は1になり、混合状態の場合、1以下になることが、理論的にわ
かっています。このメソッドを使う典型的な状況は、純粋状態と混合状態を判
別したいときです。

#### 複製

    de_clone = de.clone()

#### 部分トレース

DensOpクラスのpatraceメソッドを使います。使用例を以下に示します。

    de_reduced = de.patrace(id=[0,2])

全体系の部分系に対する密度演算子を知りたい場合に「部分トレース」という
処理を施せば良いということがわかっています。その計算を実行します。返却
値は、縮約された(部分系の)密度演算子インスタンスです。

#### 部分系

    de_partial = de.partial(id=[1,3])

#### テンソル積

２つの密度演算子のテンソル積を計算できます。使用例を以下に示します。

    de_product = de_A.tenspro(de_B)

密度演算子de_Aとde_Bのテンソル積(de_A * de_B)を計算し、新たな密度演算
子de_productを生成しています。

#### 行列の適用

DensOpクラスのapplyメソッドを使います。使用例を以下に示します。

    import numpy as np
    M = np.array([[0.0,1.0],[1.0,0.0]], id=[1])
    de.apply(matrix=M)

密度演算子rhoに対して変換行列Mがあったときに、「M * rho * M^dagger」の
計算をします。行列はnumpyの２次元配列として用意しておきます。密度演算
子よりも変換行列のサイズの方が小さくなくてはいけません。また、idで指定
する引数のリストのサイズをnとしたとき、行列の行数、列数はともに2^nでな
くてはなりません。applyメソッドは、元のインスタンスの内容を変えます。
ご注意ください。

#### 要素の表示

DensOpクラスのshowメソッドを使います。使用例を以下に示します。

    de.show()

例えば、以下のように各行列要素の値が表示されます。

    elm[0][0] = +0.0000+0.0000*i : 0.0000 |
    elm[0][1] = +0.0000+0.0000*i : 0.0000 |
    elm[1][0] = +0.0000+0.0000*i : 0.0000 |
    elm[1][1] = +1.0000+0.0000*i : 1.0000 |+++++++++++
	
部分系の表示も可能です。

    de.show(id=[0,1])
	
0番目と1番目の量子ビットに関する密度演算子を表示します。内部では0番目
と1番目の量子ビット以外の量子ビットに関して部分トレースを実行していま
す。

#### 要素の抽出

    elm = de.get_elm()
    elm = de.get_elm(id=[1,2])

#### 和とスカラー積

    de3 = de1.add(de2)
    de2 = de1.mul(0.3)

#### 密度演算子の混合

    de = DensOp.mix(densop=[de1,de2], prob=[0.2,0.8])

量子状態ではなく、複数の密度演算子を用意し、その混合で新たな密度演算子
を生成することができます。クラスメソッドなので、インスタンス生成するこ
となく、実行できます。

#### 確率

    prob = de.probability(povm=[E0,E1], id=[0,1])
    prob = de.probability(kraus=[M0,M1], id=[0,1])

kraus演算子(numpy行列)のリスト、またはPOVM演算子(numpy行列)のリストを
引数に指定し、idで測定対象となる量子ビット番号リストを指定します。各々
の測定演算に対する確率値のリストを返します。idで指定する引数のリストの
サイズをnとしたとき、kraus演算子(numpy行列)、またはPOVM演算子の行数、
列数はともに2^nでなくてはなりません。

#### 測定（CP-instrument）

    de.instrument(kraus=[M0,M1], id=[0,1])
    de.instrument(kraus=[M0,M1], id=[0,1], measured_value=1)

引数krausでKraus演算子(numpy行列)のリスト、引数idで測定対象となる量子
ビット番号リストを指定します。密度演算子をKraus表現に変更します。これ
は測定を実行するがその結果を忘れた状況に相当します（非選択的）。引数
measured_valueに測定値（Kraus演算子番号）を指定すると、密度演算子が測
定後の状態に変化します（選択的）。ただし、正規化しないので、正規化した
い場合は、以下のようにトレースで確率を求めて、それで割る必要があります。

    prob = de.trace()
    de.mul(factor=1.0/prob)

#### フィデリティ（忠実度）

	fid = de1.fidelity(de2)

密度演算子de1とde2のフィデリティを計算します。

#### トレース距離

	dis = de1.distance(de2)

密度演算子de1とde2のトレース距離を計算します。

#### スペクトル分解

	prob,qstate = de.spectrum()

密度演算子をスペクトル分解します。固有値（確率）のリストと固有ベクトル
（量子状態）のリストをリターンします。ちなみに、

	de1 = DensOp(qstate=qstate, prob=prob)

とやると、スペクトル分解の逆操作となり密度演算子は元に戻ります。つまり、
deとde1は計算誤差を除き一致します。

#### エントロピー（フォンノイマン・エントロピー）

	ent = de.entropy()

密度演算子deのフォンノイマン・エントロピーを計算します。

#### エンタングルメント・エントロピー

	ent_A = de.entropy([0,1])    # for system A
	ent_B = de.entropy([2,3,4])  # for system B

全体系に対する部分系のエントロピー（エンタングルメント・エントロピー）
を計算します。entropyメソッドに部分系を表す量子ビット番号リストを引数
として与えます。上の例では、全体系が５量子ビットで記述されている想定の
もとで、それに対する部分系A（量子ビット番号:[0,1]）および部分系B（量子
ビット番号:[2,3,4]）のエンタングルメント・エントロピーを計算しています。
全体系が純粋状態の場合、部分系Aと部分系Bのエンタングルメント・エントロ
ピーの値は一致します。

#### 条件付きエントロピー

	ent_cond = de.cond_entropy([0,1],[2,3,4])

部分系B（量子ビット番号:[2,3,4]）が定まったという条件のもとでの、部分
系A（量子ビット番号:[0,1]）の条件付きエントロピーを計算します。
S(A|B)=S(A,B)-S(A)と定義されます。古典情報理論における条件付きエントロ
ピーと違い、負の値になる場合もあります。

#### 相互情報量

	mut_info = de.mutual_info([0,1],[2,3,4])

部分系A（量子ビット番号:[0,1]）と部分系B（量子ビット番号:[2,3,4]）の相
互情報量を計算します。I(A:B)=S(A)+S(B)-S(A,B)と定義されます。AとBを入
れ替えても同じ値になります。

#### 相対エントロピー

	rel_ent = de1.relative_entropy(de2)
	
密度演算子de1とde2の相対エントロピーを計算します。

### 量子状態へのゲート適用

密度演算子として表現された量子状態に対してゲート演算することができます。
仕様はQStateクラス場合と全く同じです。以下に使用例を示します。

    de.h(0).cx(0,1)
	de.crx(0,1, phase=0.1)
    ...


以上
