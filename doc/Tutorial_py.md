Tutorial
========

## Pythonライブラリ(qlazypy)

### 使用例

まず、簡単な使用例を示します。

    from qlazypy import QState
    
    # ２つの量子ビットを|0>に初期化
    qs = QState(2)

    # 量子ゲート実行
    qs.h(0)
    qs.cx(0,1)
    qs.show()    # 量子状態の表示

    # 測定
    md = qs.m(shots=100)
	md.show()    # 測定結果の表示

    # 後始末（メモリ開放）
    qs.free()

何をやっているか順に説明します。まず、QState()で量子ビットを各々|0>に
初期化します。初期化した量子状態に対して、次々に量子ゲートを作用させ、
最後に測定して結果を表示する、というのが典型的な使用方法です。上の例で
は、０番目の量子ビットにアダマールゲートをかけ、０番目と１番目の量子ビッ
トに制御NOTゲートをかけています。qlazyではh()やcx()などの量子ゲートに
対応したメソッドを呼び出した時点で、量子状態を変更させる計算を内部で行っ
ています。他のシミュレータの多くは量子回路を定義した上で、最後にrunす
るような仕様が多いように思いますが、その点ご注意ください。

また、連続して適用したい場合、

    qs.h(0).cx(0,1)
	
のような書き方（メソッド・チェーン）も可能です。

量子状態は、show()メソッドで確認できます。上の例では、以下のような表示
がなされます。

    c[00] = +0.7071+0.0000*i : 0.5000 |++++++
    c[01] = +0.0000+0.0000*i : 0.0000 |
    c[10] = +0.0000+0.0000*i : 0.0000 |
    c[11] = +0.7071+0.0000*i : 0.5000 |++++++

２量子ビットで実行しているので、量子状態は|00>,|01>,|10>,|11>の重ね合
わせです。各々に対応した係数（複素数）をc[00],c[01],c[10],c[11]と定義
しており、それを表示しています。複素数の右に表示されている実数値
（0.5000とか0.0000）は各々の絶対値の２乗、すなわちその状態が観測される
確率を表しています。一番右に表示されている「++++++」は、その確率の大き
さを視覚的にわかりやすくするための、棒グラフです。

量子ゲートの操作が終わったら、m()メソッドで測定します。測定結果を適当
な変数で受けて、それをshow()メソッドで表示します。上の例では、例えば以
下のように表示されます。

    direction of measurement: z-axis
    frq[00] = 49
    frq[11] = 51
    last state => 00

はじめの行「direction of measurement: z-axis」は、Z軸方向の測定をして
います、ということ表しています。デフォルトの測定の方向はZ軸方向です。
他の大抵のシミュレータと違い、qlazyでは任意方向の測定もオプション等で
簡単に実行できるので、区別できるように測定方向を一応表示するようにして
います。frq[xx]は、測定の結果、|xx>だった回数を表しています。測定の回
数は、何も指定しなければ、デフォルトで100回です。上の例では、|00>だっ
た回数は49回、|11>だった回数は51回だったということを表しています。内部
で乱数を発生させることで確率的な測定をシミュレートしていますので、実行
のたびにこの回数は変わります。last stateは、最後の測定の結果が何だった
かを表しています。上の例では|00>でした。qlazyでは、測定後の状態変化も
シミュレーションしていますので、この測定後の状態に対して、

    qs.show()
	
をすると、以下のように、波束が収縮している様子も確認することができます。

    c[00] = +1.0000+0.0000*i : 1.0000 |+++++++++++
    c[01] = +0.0000+0.0000*i : 0.0000 |
    c[10] = +0.0000+0.0000*i : 0.0000 |
    c[11] = +0.0000+0.0000*i : 0.0000 |

すべて終わったら、後始末をします。

    qs.free()
	
qlazyは実質的な計算はすべてC言語で作成したライブラリで行っており、それ
をCtypesを使って呼び出す形にしています。量子状態を格納しておくメモリは
C言語側で動的に確保していますので、最後に、そのメモリを開放するという
意味でfree()が必要です。

### 量子状態へのゲート適用

#### 量子状態の生成・初期化

まず、量子状態の生成・初期化をする必要があります。量子ビット数を引数に
してQStateクラスのコンストラクタを呼び出すのが基本ですが、乱数生成のシー
ドを指定するオプションもあります。

    qs = QState(2, seed=123)

デフォルトではseedはランダムに設定されるので実行のたびに結果は変わ
りますが、このseedを指定すると、何度実行しても結果は同じになります。

この初期化について、２つ注意事項があります。

1. 状態は常に|00...0>になります。どれかを|1>にする初期化機能は用意して
いません。それをしたい場合はパウリXゲートを使ってビット反転してください。
2. 指定できる量子ビット数の上限は30です。30を超えるとエラーになります。

また、numpyのベクトルを使って、量子状態を初期化することもできます。使
い方は、以下です。

    import numpy as np
    vec = np.array([1,0,0,0])
    qs = QState(vector=vec)

指定するベクトルの次元は２のべき乗である必要があります。

#### 量子状態のリセット

すでに生成済みの量子状態を破棄することなく、再度初期化して使いたい場合
は、reset()メソッドを使います。例えば、

    qs = QState(2)
	qs.x(0).h(1).cx(0,1)
    ...

という一連の処理を行って結果を得た後、qs.free()して再度qs=QState(2)し
ないで、qsを|00...0>の状態にして、再び一連の処理を実行する場合、

    qs.reset()

とすれば、qsは強制的に|00...>となります。これは、同じ量子回路を何度も
繰り返し適用しながら、何らかの統計量を得たいような場合に便利な機能です。

また、

    qs.reset(qid=[1,5])

のように、量子番号リストを引数で与えると、その番号に対応した量子ビット
のみを強制的に|0>にすることもできます。

#### 量子状態のメモリ解放

先程説明した通り、量子状態を使った作業がすべて終わったら、内部のメモリ
を解放する必要があります（本当は、プログラムの一番最後のfree()は、やら
なくてもプログラム終了とともに、勝手にOSが解放してくれるはずなので不要
ですが、習慣づけておくのは悪いことではないと思います）。

    qs.free()
	
複数の量子状態のインスタンスがある場合、クラス・メソッド'free_all'で一
気に解放することができます。

    qs_0 = QState(1)
    qs_1 = QState(1)
    qs_2 = QState(1)
    ...
    QState.free_all(qs_0, qs_1, qs_2)

また、引数に指定するのは量子状態のリストやタプルであっても良いですし、
それらの入れ子でもOKです。例えば、

    qs_A = [qs_1, qs_2]
    QState.free_all(qs_0, qs_A)

    qs_B = [qs_3, [qs_4, qs_5]]
    QState.free_all(qs_B)

という指定の仕方でも大丈夫です。ただし、同じ量子状態インスタンスを２度
以上解放するのはNGです。

    QState.free_all(qs_0, [qs_0, qs_1])
	
こうしてしまわないようにご注意を。


##### 30の上限を外したい場合

qlazy/c/qlazy.hの以下の行の数字を変えて、再度コンパイルして、

    #define MAX_QUBIT_NUM      30

さらに、qlazy/py/qlazypy/config.pyの以下の行の数字を上と同じになるよう
に変更してください。

    MAX_QUBIT_NUM = 30

#### パウリX,Y,Zゲート

    qs.x(q)
    qs.y(q)
    qs.z(q)

qには量子ビット番号を指定します（以下、同様）。
	
#### ルートパウリXゲート

２乗したらXになるゲートです。

    qs.xr(q)
    qs.xr_dg(q)  # エルミート共役

#### アダマールゲート

    qs.h(q)

#### 位相シフトゲート

    qs.s(q)
    qs.t(q)
    qs.s_dg(q)  # エルミート共役
    qs.t_dg(q)  # エルミート共役
	
#### 回転ゲート

    qs.rx(q, phase=xxx)  # X軸周りの回転
    qs.ry(q, phase=xxx)  # Y軸周りの回転
    qs.rz(q, phase=xxx)  # Z軸周りの回転
	
phase（実数値）が指定されなければ0ラジアンとみなされます（つまり何もし
ない）。phaseに指定する値の単位はPIラジアンです。なので、0.5は0.5*PIラ
ジアンを意味します。

#### 回転ゲート(U1,U2,U3 by IBM)

    qs.u1(q, alpha=xxx)
    qs.u2(q, alpha=xxx, beta=xxx)
    qs.u3(q, alpha=xxx, beta=xxx, gamma=xxx)
	
alpha,beta,gamma（実数値）が指定されなければ0ラジアンとみなされます
（つまり何もしない）。phaseに指定する値の単位はPIラジアンです。なので、
0.5は0.5*PIラジアンを意味します。

#### 制御ユニタリゲート

パウリX,Y,Zゲート、ルートパウリXゲート、アダマールゲート、位相シフトゲー
ト、回転ゲートを各々制御ユニタリ化したゲートです。引数q0,q1は各々量
子ビット番号を表しています（以下、同様）。q0が制御量子ビット、q1が標
的量子ビットです。

    qs.cx(q0,q1)              # 制御Xゲート（制御NOT,CNOT）
    qs.cy(q0,q1)              # 制御Xゲート
    qs.cz(q0,q1)              # 制御Zゲート
    qs.cxr(q0,q1)             # 制御XR(ルートパウリX)ゲート
    qs.cxr_dg(q0,q1)          # 制御XR+(ルートパウリX)ゲート (エルミート共役)
    qs.ch(q0,q1)              # 制御Hゲート
    qs.cs(q0,q1)              # 制御Sゲート
    qs.cs_dg(q0,q1)           # 制御S+ゲート (エルミート共役)
    qs.ct(q0,q1)              # 制御Tゲート
    qs.ct_dg(q0,q1)           # 制御T+ゲート (エルミート共役)
	qs.cp(q0,q1, phase=xxx)   # 制御位相シフトゲート
	qs.crx(q0,q1, phase=xxx)  # 制御X軸回転ゲート
	qs.cry(q0,q1, phase=xxx)  # 制御Y軸回転ゲート
	qs.crz(q0,q1, phase=xxx)  # 制御Z軸回転ゲート
	qs.cu1(q0,q1, alpha=xxx)                       # 制御U1ゲート
	qs.cu2(q0,q1, alpha=xxx, beta=xxx)             # 制御U2ゲート
	qs.cu3(q0,q1, alpha=xxx, beta=xxx, gamma=xxx)  # 制御U2ゲート

#### 交換ゲート（スワップゲート）

    qs.sw(q0,q1)  # q0とq1を入れ替え

#### トフォリゲート

    qs.ccx(q0,q1,q2)  # q0,q1: 制御ビット

#### 制御スワップゲート（フレドキンゲート）

    qs.csw(q0,q1,q2)  # q0: 制御ビット

#### マルチ制御Xゲート

通常のトフォリゲートは、2つの制御ビットと1つの標的ビットを持つ制御Xゲー
トですが、3つ以上の制御ビットを持つ制御Xゲート演算を実行できます。ここ
では「マルチ制御Xゲート」と呼ぶことにします。

    qs.mcx(qid=[q0,q1,..])

任意の数の量子ビットを対象に演算することができますので、引数には量子ビッ
ト番号のリストを指定します。そのリストの一番最後の要素が標的ビット番号、
それ以外の要素が制御ビット番号のリストと解釈されます。

ここで、引数は量子ビット番号の「リスト」であることにご注意ください。
qlazyでは、数が不定の量子ビット番号を指定する必要がある場合、メソッド
や関数に「リスト」として与えます（という仕様上のルールにしています）。

### カスタム・ゲートの追加

上で説明した基本的なゲートを組み合わせてユーザーが独自に作成したカスタ
ム・ゲートを、QStateクラスのメソッドとして登録したい場合は、QStateクラ
スのクラス・メソッド'add_method'を使います。

例えば、指定した３つの量子ビット番号に各々X,Y,Zゲートを演算する'foo'ゲー
トを登録したいとします。まず、その演算を以下のように関数定義します。引
数'self'は、QStateのインスタンスで、このselfに対してゲート演算を適用し
て、関数の最後でselfをリターンするようにします。

    def foo(self,q0,q1,q2):
        self.x(q0).y(q1).z(q2)
        return self

これをメソッドとして登録するには、以下のようにします。

    QState.add_method(foo)

'foo'を使用する場合は、

    qs = QState(3)
    ...
    qs.foo(0,1,2)

という具合に、通常のゲート演算と同様の書き方で実行できます。


### 量子ビット番号（レジスタ）の準備

大きめの量子回路を実行する場合、量子ビット番号（レジスタ）をグループ化
した方が、わかりやすいプログラムになることが多々あります。QStateクラス
のクラス・メソッドとして、レジスタをクリエイトする'create_register'と
初期化する'init_register'を使うことができます。'create_register'は引数
に量子ビット数を指定することで、量子ビット数分の番号を格納するためのリ
ストを返します。この時点で要素はすべて'0'になっていま
す。'init_register'は、その量子ビット番号リストに順番に重複なく、数字
を入れていき、全量子ビット数を返します。典型的な使用例を以下に示します。

    qid_A = QState.create_register(2)
	qid_B = QState.create_register(3)
    qubit_num = QState.init_register(qid_A,qid_B)
    qs = QState(qubit_num)
    ...

レジスタAを2量子ビット、レジスタBを3量子ビット分確保する処理です
（init_registerの引数に与えるリストの数は何個でも良いです）。この例の
場合、qid_A,qid_B,qubit_numには、以下のような値が入ることになります。

    >> print(qid_A)
    [0,1]
    >> print(qid_B)
    [2,3,4]
    >> print(qubit_num)
    5


### 量子状態の表示

#### 正規化

ノルムを1にする正規化に加えて、全体にかかっている位相項を括り出して、
これを無視して表示するようにしています。位相項を括り出す際には、
C[00..0]の係数が正の実数になるようにしています。

#### 特定量子ビットの状態表示

量子ビット全体の状態を表示するのが基本ですが、特定の量子ビットを選択し
て表示することもできます。

    qs.show(qid=[q0,q1...])

例えば、

    qs = QState(3)
	qs.h(0)
	qs.h(2)
	qs.show()

とすると、全体の状態が表示されます。

    c[000] = +0.5000+0.0000*i : 0.2500 |++++
    c[001] = +0.5000+0.0000*i : 0.2500 |++++
    c[010] = +0.0000+0.0000*i : 0.0000 |
    c[011] = +0.0000+0.0000*i : 0.0000 |
    c[100] = +0.5000+0.0000*i : 0.2500 |++++
    c[101] = +0.5000+0.0000*i : 0.2500 |++++
    c[110] = +0.0000+0.0000*i : 0.0000 |
    c[111] = +0.0000+0.0000*i : 0.0000 |

ここで、

    qs.show([0,2])

とすると、以下になります。

    c[00] = +0.5000+0.0000*i : 0.2500 |++++
    c[01] = +0.5000+0.0000*i : 0.2500 |++++
    c[10] = +0.5000+0.0000*i : 0.2500 |++++
    c[11] = +0.5000+0.0000*i : 0.2500 |++++

また、

    qs.show([1])
	
とすると、以下になります。

    c[0] = +1.0000+0.0000*i : 1.0000 |+++++++++++
    c[1] = +0.0000+0.0000*i : 0.0000 |

内部的にどんなことをやっているかというと、表示したい特定の量子ビット以
外のビットを仮に測定し無理やり波束を収縮させます。結果得られた確率振幅
の係数たちの中から、表示したい量子ビットの組み合わせに相当するノンゼロ
の係数をピックアップして表示します。ノンゼロの係数がなかったらゼロとし
ます。最後に、測定前の状態に戻します。以上がやっている内容です。

したがって、表示したい量子ビットとそれ以外の量子ビットの世界がきっぱり
とテンソル積で分解できる形になっていれば、これで予想通りの表示がなされ
ます。問題はエンタングルしていてテンソル積の形になっていない場合です。
この実装だとshowで表示するたびに結果が変わります。例えば、

    c[00] = +0.7071+0.0000*i : 0.5000 |++++++
    c[01] = +0.0000+0.0000*i : 0.0000 |
    c[10] = +0.0000+0.0000*i : 0.0000 |
    c[11] = +0.7071+0.0000*i : 0.5000 |++++++

のようなエンタングルした状態があったときに、

    qs.show([0])
   
をやると、

    c[0] = +1.0000+0.0000*i : 1.0000 |+++++++++++
    c[1] = +0.0000+0.0000*i : 0.0000 |

となったり、

    c[0] = +0.0000+0.0000*i : 0.0000 |
    c[1] = +1.0000+0.0000*i : 1.0000 |+++++++++++

となったりします。

まー、これはこれで面白いし（エンタングルしていたということがわかる）、
こんな適当実装でも結構使える場合も多いかなと個人的には思っています。

ちなみに、これは、エンタングルした純粋状態の部分トレースをとった結果と
して現れた|0>と|1>の混合状態を表示していることに相当します。純粋状態で
はないので、複数の純粋状態が確率的に表示されるわけです。

ということですので、注意して使ってください。

#### 量子状態のデータ取得

ampプロパティで、確率振幅の各々の複素係数をnumpy配列として取得できます。

    qs.amp

get_amp()メソッドで、特定の量子ビットに対応した確率振幅の複素係数をnumpy
配列として取得できます。

    qs.get_amp(qid=[q0,q1...])

#### 部分系

特定の量子ビットに対応した部分系の量子状態を取得できます。

    qs_partial = qs.partial(qid=[1,3])

#### ブロッホ球上での座標

blochメソッドで、特定の１つの量子ビットに対応したブロッホ球での座標値
を取得できます。thetaをZ軸とのなす角、phiをZ軸周りの回転角とすると、以
下のように座標値を取得できます。角度の単位はpi(ラジアン)です。0.5は
0.5*piを表します。

    theta, phi = qs.bloch(q)

ただし、複数の量子ビットを同時に指定することはできません。引数を指定し
ない場合、0が指定されたものとみなされます。

### 測定

#### 測定の実行

    md = qs.m(qid=[q0,q1...], shots=aaa, angle=bbb, phase=ccc)

qid,shots,angle,phaseの指定をしない場合、通常のZ軸方向の測定を1回実施
します（shotsのデフォルト値はv0.0.33で100から1に変更しました）。idには
測定したい量子ビットの番号リストを指定します。shotsには測定回数を指定
します。angle,phaseは測定の方向を表しており、angleにはZ軸とのなす角を
単位PIラジアンで指定します。phaseにはX軸プラス方向を基準にしたZ軸周り
の角度を単位PIラジアンで指定します。ブロッホ球の２つの角をイメージして
もらえれば良いです。この測定メソッドは、測定クラスの インスタンスを返
すので、それを例えば変数mdで受けるというのが、一つの使い方です。

X軸、Y軸、Z軸方向の測定をするメッソドも用意されています。

    md = qs.mx(qid=[q0,q1...], shots=aaa)
    md = qs.my(qid=[q0,q1...], shots=aaa)
    md = qs.mz(qid=[q0,q1...], shots=aaa)

mz()はm()と同じです。

また、ベル測定のメソッドもあります。

    md = qs.mb(qid=[q0,q1], shots=aaa)

測定のメソッドの後にメソッド・チェーンでQStateのメソッドをつなげること
はできませんので、ご注意ください。つまり、

    qs.h(0).cx(0,1).m([0],shots=10).x(0).m(id=[1],shots=20)

というメソッド・チェーンは実行できません。この演算をやりたい場合は、

    qs.h(0).cx(0,1).m(qid=[0],shosts=10)
    qs.x(1).m(qid=[1], shots=20)

という具合に、2行に分けてください。

ここで、もう一つ注意点があります。上の例の1行目の測定は、HゲートとCXゲー
トを適用した状態に対して、10回の測定シミュレーションを行います。シミュ
レータなので、測定しても量子状態が消えることはないので、HゲートとCXゲー
トを10回適用しなくても、測定シミュレーションはできます。で、10回目の測
定結果に対応した量子状態がqsに格納されることになります（例えば、測定結
果が'0'だった場合、qsは|00>となります）。2行目は、前段最後の測定後の量
子状態（例えば、|00>）に対してXゲートの演算がなされます。それに対して、
20回の測定シミュレーションがなされます。したがって、「H-CX-M-X-M」とい
う量子回路を何度も通して、測定した結果とは異なります。

「H-CX-M-X-M」の回路を何度も通すシミュレーションは、ちょっと面倒ですが、
例えば、以下のようにやればできます。

    from collections import Counter
    from qlazypy import QState
    
    def run_qc(shots):
        qs = QState(2)
        qs.h(0).cx(0,1).m(qid=[0])
        qs.x(1).m(qid=[1], shots=shots, tag='foo')
        freq = qs.m_freq(tag='foo')
		qs.free()
		return freq
    
    freq = Counter()
    for _ in range(10):
        freq += run_qc(10)
    print(freq)

tag引数とかm_freq()メソッドについては、少し下の「測定の実行と測定デー
タの取得（もう一つの方法）」に説明がありますので、そちらを見てください。

#### 測定結果の表示

show()メソッドで表示します。Z軸方向以外の測定結果の表示例を以下に示し
ます。Z軸方向の測定結果は|0>,|1>ですが、それ以外の方向は|0>,|1>にはな
らないので、|u>,|d>になるとして、結果を表しています。

X軸方向の測定結果

    direction of measurement: x-axis
    frq[u] = 49
    frq[d] = 51
    last state => u

Y軸方向の測定結果

    direction of measurement: y-axis
    frq[u] = 51
    frq[d] = 49
    last state => d

任意方向の測定結果（angle=0.2, phase=0.3の場合）

    direction of measurement: theta=0.200*PI, phi=0.300*PI
    frq[u] = 90
    frq[d] = 10
    last state => u

ベル測定の結果

    bell-measurement
    frq[phi+] = 47
    frq[phi-] = 53
    last state => phi+  # phi+,phi-,psi+,psi-のどれか

#### 測定データの取得

    md.frq  # 頻度リスト
	md.lst  # 最後の結果
	
最後の結果は、十進数になります。Z軸方向以外の測定の場合、u=>0,d=>1のよ
うに読み替えて、十進数にしています。ベル測定の場合は、phi+ => 0, phi-
=> 3, psi+ => 1, psi- => 2と定義されています。

#### 測定の実行と測定データの取得（もう一つの方法）

測定実行時にその測定結果にタグを付与して内部的に保持しておき、後からそ
の結果を参照する、というやり方も可能です（こっちの方を標準にしようか
なと、少し思っていたりします）。例えば、

	qs.m(shots=100, tag='foo')
	freq = qs.m_freq(tag='foo')
	print(freq)
    >> Counter({'00': 54, '11': 46})

のように、測定実行時にタグ'foo'を指定して測定データを保持しておき、
m_freqメソッドにタグ'foo'を指定することで測定結果を得ることができます。
python標準のコンテナデータ型のサブクラスCounter形式で結果が返ってきま
す。測定関連のメソッドm,mx,my,mz,mbすべてで同様に実行可能です。

測定の際、tagの指定を省略した場合は、'default'というタグに保持されます。
resultメソッドで参照する際にtagの指定を省略すると、'default'タグが指定
されたとみなされ、結果を返しますので、

	qs.m(shots=100)
	freq = qs.m_freq()
	print(freq)
    >> Counter({'00': 51, '11': 49})

という書き方も可能です。計算したい量子回路に測定が1箇所しかない場合は、
これで十分です。

複数のQStateクラスのインスタンスがあって、それに対して別々に測定する場
合、インスタンスごとのタグ名で各測定結果が保持されますので、以下のよう
に指定しても大丈夫です。

    qs_0 = QState(1)
	qs_0.m(shots=20, tag='bar')
    
    qs_1 = QState(2)
    qs_1.h(0).cx(0,1).m(shots=100, tag='bar')
    qs_1.m(shots=100, tag='hoge')
    
    print(qs_0.m_freq(tag='bar'))
    >> Counter({'0': 12, '1': 8})
    
    print(qs_1.m_freq(tag='bar'))
    >> Counter({'00': 51, '11': 49})
    
    print(qs_1.m_freq(tag='hoge'))
    >> Counter({'11': 100})

測定結果の頻度分布を得るm_freq以外にも、タグで管理された測定データを参
照するいくつかのメソッドがありますので、以下で説明します。

測定データ（複数回測定する場合は最後の測定結果）を取得するm_value()と
いうメソッドは、

    print(qs.m_value(tag='foo'))
    >> 0

のように使います。結果は整数値になります。２進数の文字列で値を取得した
い場合は、引数binaryにTrueを指定します。
	
    print(qs.m_value(tag='foo', binary=True))
    >> '00'

となります。

測定データの中の特定の量子ビットが'0'だったのか'1'だったのかを知るため
には、m_bit()メソッドを使います。以下のように、取得したい量子ビット番
号を最初に指定して、続けて他の引数を指定します。

    print(qs.m_bit(0, tag='foo'))
    >> 1

論理値(True,False)で取得したい場合は、引数booleanにTrueを指定します。

    print(qs.m_bit(0, tag='foo', boolean=True))
    >> True

これと、同じことを（少しだけ短くかける）m_is_zero(),m_is_one()というメ
ソッドもあります。

    print(qs.m_is_zero(0, tag='foo'))
    >> False
    print(qs.m_is_one(0, tag='foo'))
    >> True

例えば、測定した量子ビットが0か1かに応じて、他の量子ビットに特定のゲー
トを演算するかしないかを制御したい場合（制御ユニタリとは違いますよ、念
ため）、以下のように割とコンパクトに書けるのではないかなー、と思います。

    if qs.m_is_one(0): qs.x(1)

あるいは、後置if（３項演算子）を使うと、

    qs.x(1) if qs.m_is_one(0) else True

こんな感じです（どうでもいいですが、'else True'はこの場合、意味がない
です。が、こうしないとシンタックスエラーになります。Pythonの仕様なので
仕方ないです）。

ここまでの例は、メソッドm()による測定、つまりZ軸方向の測定でしたが、他
の角度での測定の場合、結果を取得する際に角度を指定する必要があります。
測定時と違う角度で結果を参照しようとすると、まだ測定されていないという、
エラーが返ってきます。例えば、以下のようにやります。

    qs = QState(1)
    qs.mx(tag='foo')  # angle=0.5
    print(qs.m_value(tag='foo', angle=0.5))
    print(qs.m_bit(0, tag='foo', angle=0.5))
    print(qs.m_is_zero(0, tag='foo', angle=0.5))
    print(qs.m_is_one(0, tag='foo', angle=0.5))
    print(qs.m_freq(tag='foo', angle=0.5))
    qs.free()

あるいは、

    qs = QState(1)
    qs.m(tag='foo', angle=0.25, phase=0.25)
    print(qs.m_value(tag='foo', angle=0.25, phase=0.25))
    print(qs.m_bit(0, tag='foo', angle=0.25, phase=0.25))
    print(qs.m_is_zero(0, tag='foo', angle=0.25, phase=0.25))
    print(qs.m_is_one(0, tag='foo', angle=0.25, phase=0.25))
    print(qs.m_freq(tag='foo', angle=0.25, phase=0.25))
    qs.free()

です。

### 量子状態とオブザーバブル

ハミルとニアンをはじめとする観測可能な物理量のことを「オブザーバブル」
といいます。qlazyでは、量子状態とオブザーバブルにまつわるいくつかの計
算もできます。オブザーバブルを利用可能とするために、QStateクラスに加え、
Observableクラスをimportする必要があります。

    from qlazypy import QState,Observable

利用可能な計算は、

    * 量子状態の時間発展
    * オブザーバブルの期待値
	
です。

#### 量子状態の時間発展

系のハミルトニアンが与えられたら、量子状態の時間発展は形式的にはユニタ
リ演算子として記述できます。このユニタリ演算子のことを「時間発展演算子」
と呼びます。特に、スピンのような２準位の多体系の場合、この時間発展演算
子は、量子回路によって近似的に表現できることが知られています。qlazyで
は、この計算を実装しています。QStateクラスのevolveメソッドを使います。
使用例を以下に示します。

    qs = QState(2)
    hm = Observable("-2.0+z_0*z_1+x_0+x_1")
    qs.evolve(observable=hm, time=0.1, iter=10)
	
１行目で、２粒子を定義しています。量子状態は|00>に初期化されます。２行
目で、"-2.0*Z0*Z1+X0+X1"というパウリ行列で記述されるハミルトニアンを定
義しています。３行目で、このハミルトニアンで規定される時間発展を量子状
態qsに施しています。ここで、引数timeは時間です。iterは近似精度を上げる
ために内部で処理される繰り返し数(整数値)です。timeよりも十分大きな値を
指定してください。

#### オブザーバブルの期待値

QStateクラスのexpectメソッドを使います。使用例を以下に示します。上で示
した例の続きです。

    ob = Observable("z_0+z_1")
    exp = qs.expect(observable=ob)

１行目で、期待値を求めたい物理量(オブザーバブル)を指定します。２行目で、
現在の量子状態qsに対するオブザーバブルの期待値を計算して、変数exp(実数
値)に格納しています。

### 量子状態に関する計算

#### ２つの量子状態の内積

QStateクラスのinproメソッドを使います。使用例を以下に示します。

    qs_0 = QState(2)
    qs_1 = QState(2).x(0).x(1)
    v = qs_0.inpro(qs_1)

状態|00>と状態|11>の内積を計算しています。

#### ２つの量子状態の忠実度

QStateクラスのfidelityメソッドを使います。使用例を以下に示します。

    qs_0 = QState(2)
    qs_1 = QState(2).x(0).x(1)
    v = qs_0.fidelity(qs_1)

状態|00>と状態|11>の内積の絶対値を計算しています。

#### ２つの量子状態のテンソル積

QStateクラスのtensproメソッドを使います。使用例を以下に示します。

    qs_1 = QState(1).x(0)
    qs_2 = QState(2).h(0).cx(0,1)
    qs_3 = qs_1.tenspro(qs_2)

|1>と(|00>+|11>)/sqrt(2)のテンソル積を作成し、変数qs_3に格納しています。

#### 量子状態の複合

QStateクラスのcompositeメソッドを使います。

    qs_com = qs.composite(4)

qsを4つ複合した状態が生成されます。

#### 量子状態への行列適用

QStateクラスのapplyメソッドを使います。行列をnumpyの配列として定義し、
applyメソッドの引数として渡します。使用例を以下に示します。

    qs = QState(1)	
    M = np.array([[0,1],[1,0]])
	qs.apply(M)

１量子ビット状態|0>にビット反転演算（Xゲート）を適用しています。


### 密度演算子

量子状態には純粋状態と混合状態があります。混合状態は、複数の純粋状態が
ある確率でもって出現するアンサンブル{p(i), |phi(i)>} (i=0,1,2,...)とし
て定義されます。このような混合状態も含めて、量子状態を統一的に記述する
便利な記法として「密度演算子」が導入されませした。その定義は、密度演算
子をrhoとすると、「rho = ∑_i p(i) |phi(i)><phi(i)|」です。

qlazyには、通常の量子状態の集合から密度演算子をつくり、各種計算する機
能があります。以下にそれらを記載します。

#### 作成

DensOpクラスが密度演算子を表します。使用例を以下に示します。

    from qlazypy import QState,DensOp

    qs1 = QState(2).h(0).cx(0,1)
    qs2 = QState(2).x(0).z(1)

    de = DensOp(qstate=[qs1,qs2], prob=[0.3,0.7])

２つの量子状態qs1,qs2があったとき、DensOpの引数として、量子状態のリス
トと各々の出現確率を表すリストを与えると、密度演算子のインスタンスが返っ
てきます。量子状態は、何個指定しても良いです（メモリが許す限り）。prob
を省略した場合、各量子状態が等しい確率で混合しているものとして密度演算
子が計算されます。

numpyの行列（２次元配列）を指定して生成することもできます。使い方は、
以下です。

    import numpy as np
	mat = np.array([[1,0],[0.0]])
    de = DensOp(matrix=mat)

#### メモリ解放

量子状態インスタンスと同様、密度演算子を使った作業がすべて終わったら、
内部のメモリを解放する必要があります。

    de.free()
	
複数の密度演算子のインスタンスがある場合、クラス・メソッド'free_all'で
一気に解放することができます。

	mat = np.array([[0.3, 0.1], [0.1, 0.7]])
    de_0 = DensOp(matrix=mat)
    de_1 = DensOp(matrix=mat).x(0)
    de_2 = DensOp(matrix=mat).h(0)
    ...
    DensOp.free_all(de_0, de_1, de_2)

また、引数に指定するのは密度演算子のリストやタプルであっても良いですし、
それらの入れ子でもOKです。例えば、

    de_A = [de_1, de_2]
    DensOp.free_all(de_0, de_A)

    de_B = [de_3, [de_4, de_5]]
    DensOp.free_all(de_B)

という指定の仕方でも大丈夫です。ただし、同じ密度演算子インスタンスを２度
以上解放するのはNGです。

    DensOp.free_all(de_0, [de_0, de_1])
	
こうしてしまわないようにご注意を。

#### トレース

DensOpクラスのtraceメソッドを使います。使用例を以下に示します。

    tr = de.trace()

密度演算子のトレースは理論的には「常に1である」ということになっている
ので、たいていの場合、あまり意味はないメソッドですが、密度演算子に対し
て、何らかの行列変換を適用しておいて(後述)、そのトレースを計算したい場
合があります。その場合、このメソッドを使うことで、計算できます。

#### ２乗のトレース

DensOpクラスのsqtraceメソッドを使います。使用例を以下に示します。

    sqtr = de.sqtrace()

密度演算子を２乗してから、そのトレースをとります。純粋状態の密度演算子
の場合、この値は1になり、混合状態の場合、1以下になることが、理論的にわ
かっています。このメソッドを使う典型的な状況は、純粋状態と混合状態を判
別したいときです。

#### 複製

    de_clone = de.clone()

#### 部分トレース

DensOpクラスのpatraceメソッドを使います。使用例を以下に示します。

    de_reduced = de.patrace(qid=[q0,q1,...])

全体系の部分系に対する密度演算子を知りたい場合に「部分トレース」という
処理を施せば良いということがわかっています。その計算を実行します。返却
値は、縮約された(部分系の)密度演算子インスタンスです。

#### 部分系

    de_partial = de.partial(qid=[q0,q1,...])

#### テンソル積

２つの密度演算子のテンソル積を計算できます。使用例を以下に示します。

    de_product = de_A.tenspro(de_B)

密度演算子de_Aとde_Bのテンソル積(de_A (X) de_B)を計算し、新たな密度演
算子de_productを生成しています（(X)は丸付きの☓のつもり）。

#### 密度演算子の複合

DensOpクラスのcompositeメソッドを使います。

    de_com = de.composite(4)

deを4つ複合した状態が生成されます。

#### 行列の適用

DensOpクラスのapplyメソッドを使います。使用例を以下に示します。

    import numpy as np
    M = np.array([[0.0,1.0],[1.0,0.0]])
    de.apply(matrix=M)

密度演算子rhoに対して変換行列Mがあったときに、「M * rho * M^dagger」の
計算をします。行列はnumpyの２次元配列として用意しておきます。密度演算
子よりも変換行列のサイズの方が小さくなくてはいけません。また、idで指定
する引数のリストのサイズをnとしたとき、行列の行数、列数はともに2^nでな
くてはなりません。applyメソッドは、元のインスタンスの内容を変えます。
ご注意ください。

#### 要素の表示

DensOpクラスのshowメソッドを使います。使用例を以下に示します。

    de.show()

例えば、以下のように各行列要素の値が表示されます。

    elm[0][0] = +0.0000+0.0000*i : 0.0000 |
    elm[0][1] = +0.0000+0.0000*i : 0.0000 |
    elm[1][0] = +0.0000+0.0000*i : 0.0000 |
    elm[1][1] = +1.0000+0.0000*i : 1.0000 |+++++++++++
	
部分系の表示も可能です。

    de.show(qid=[q0,q1,...])

例えば、

    de.show(qid=[0,3])

とすると、0番目と3番目の量子ビットに関する密度演算子を表示します。内部
では0番目と3番目の量子ビット以外の量子ビットに関して部分トレースを実行
しています。

#### 要素の抽出

    elm = de.get_elm()
    elm = de.get_elm(id=[1,2])

#### 和とスカラー積

    de.add(de_0)
    de.mul(0.3)

deにde_0を足して、さらに0.3倍する例です。add,mulはもとのインスタンスの
内容を変えます。

#### 密度演算子の混合

    de = DensOp.mix(densop=[de1,de2], prob=[0.2,0.8])

量子状態ではなく、複数の密度演算子を用意し、その混合で新たな密度演算子
を生成することができます。クラスメソッドなので、インスタンス生成するこ
となく、実行できます。

#### 確率

    prob = de.probability(povm=[E0,E1], qid=[0,1])
    prob = de.probability(kraus=[M0,M1], qid=[0,1])

kraus演算子(numpy行列)のリスト、またはPOVM演算子(numpy行列)のリストを
引数に指定し、qidで測定対象となる量子ビット番号リストを指定します。各々
の測定演算に対する確率値のリストを返します。qidで指定する引数のリスト
のサイズをnとしたとき、kraus演算子(numpy行列)、またはPOVM演算子の行数、
列数はともに2^nでなくてはなりません。

#### 測定（CP-instrument）

    de.instrument(kraus=[M0,M1], qid=[0,1])
    de.instrument(kraus=[M0,M1], qid=[0,1], measured_value=1)

引数krausでKraus演算子(numpy行列)のリスト、引数qidで測定対象となる量子
ビット番号リストを指定します。密度演算子をKraus表現に変更します。これ
は測定を実行するがその結果を忘れた状況に相当します（非選択的）。引数
measured_valueに測定値（Kraus演算子番号）を指定すると、密度演算子が測
定後の状態に変化します（選択的）。ただし、正規化しないので、正規化した
い場合は、以下のようにトレースで確率を求めて、それで割る必要があります。

    prob = de.trace()
    de.mul(factor=1.0/prob)

#### フィデリティ（忠実度）

	fid = de1.fidelity(de2)

密度演算子de1とde2のフィデリティを計算します。

#### トレース距離

	dis = de1.distance(de2)

密度演算子de1とde2のトレース距離を計算します。

#### スペクトル分解

	qstate,prob = de.spectrum()

密度演算子をスペクトル分解します。固有値（確率）のリストと固有ベクトル
（量子状態）のリストをリターンします。ちなみに、

	de1 = DensOp(qstate=qstate, prob=prob)

とやると、スペクトル分解の逆操作となり密度演算子は元に戻ります（計算誤
差を除き、ですが）。

#### エントロピー（フォンノイマン・エントロピー）

	ent = de.entropy()

密度演算子deのフォンノイマン・エントロピーを計算します。

#### エンタングルメント・エントロピー

	ent_A = de.entropy(qid=[0,1])    # for system A
	ent_B = de.entropy(qid=[2,3,4])  # for system B

全体系に対する部分系のエントロピー（エンタングルメント・エントロピー）
を計算します。entropyメソッドに部分系を表す量子ビット番号リストを引数
として与えます。上の例では、全体系が５量子ビットで記述されている想定の
もとで、それに対する部分系A（量子ビット番号:[0,1]）および部分系B（量子
ビット番号:[2,3,4]）のエンタングルメント・エントロピーを計算しています。
全体系が純粋状態の場合、部分系Aと部分系Bのエンタングルメント・エントロ
ピーの値は一致します。

#### 条件付きエントロピー

	ent_cond = de.cond_entropy([0,1],[2,3,4])

部分系B（量子ビット番号:[2,3,4]）が定まったという条件のもとでの、部分
系A（量子ビット番号:[0,1]）の条件付きエントロピーを計算します。
S(A|B)=S(A,B)-S(A)と定義されます。古典情報理論における条件付きエントロ
ピーと違い、負の値になる場合もあります。

#### 相互情報量

	mut_info = de.mutual_info([0,1],[2,3,4])

部分系A（量子ビット番号:[0,1]）と部分系B（量子ビット番号:[2,3,4]）の相
互情報量を計算します。I(A:B)=S(A)+S(B)-S(A,B)と定義されます。AとBを入
れ替えても同じ値になります。

#### 相対エントロピー

	rel_ent = de1.relative_entropy(de2)
	
密度演算子de1とde2の相対エントロピーを計算します。

### 量子状態へのゲート適用

密度演算子として表現された量子状態に対してゲート演算することができます。
仕様はQStateクラス場合と全く同じです。以下に使用例を示します。

    de.h(0).cx(0,1)
	de.crx(0,1, phase=0.1)
    ...


以上
